#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <pwd.h>
#include <errno.h>
#include <string.h>

#define MAX_USERNAME_LENGTH 32
#include "single_file_contfig.h" //generated by ./install.sh

void error(const char* error) {
	fprintf(stderr, "rut: %s", error);
	if(errno)
		fprintf(stderr, ": %s", strerror(errno));

	fputc('\n', stderr);
	exit(1);
}

#ifndef skip_password
#define _XOPEN_SOURCE // for get_pass
#include <crypt.h>
#include <shadow.h>
bool ask_password(__uid_t user_id, struct passwd* user_data) {
	struct spwd *shadow_data = getspnam(user_data->pw_name);
	if (shadow_data == NULL && errno == EACCES)
		error("no permission to read shadow password file");

	//shadow password contains the hashed password
	if (shadow_data)
		user_data->pw_passwd = shadow_data->sp_pwdp; //so it'd be easier to read

	const char* pass = getpass("[rut] password for " name ": "); //ask for the password

	//hash it
	char* encrypted_pass = crypt(pass, user_data->pw_passwd);
	//check if the hash is the same as the shadow.
	return strcmp(encrypted_pass, user_data->pw_passwd) == 0;
}
#endif //skip_password

bool auth() {
	__uid_t uid = getuid(); //get real user id
	if(uid == 0) return true; //if already root
	struct passwd* user_data = getpwuid(uid);
	if(user_data == NULL)
		error("can not get data");

	if(strncmp(name, user_data->pw_name, MAX_USERNAME_LENGTH) == 0) {
	#ifdef skip_password
		return true;
	#else
		return ask_password(uid, user_data);
	#endif // skip_password
	}

	return false; //if user is not the defined user
}

int main(int argc, char const *argv[], const char* envp[]) {
	if(argc < 2)
		error("runs command as root (single user mode)\n"
			  "usage: rut <program> <args>");

	if(!auth())
		error("either you are not \"" name "\" or you entered a wrong password");

	//set user_id to root's
	if (setuid(0) != 0)
    	error("can not set userid to root's");

	//execute, don't fork since it's the exitpoint anyway.
	execvpe(argv[1], &argv[1], envp);
	return 0;
}